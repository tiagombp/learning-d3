Shirley!

http://slides.com/shirleywu/fm-d3intro#/
@sxywu
d3.unconf
metis?
http://sxywu.com/
https://www.reddit.com/r/dataisbeautiful/comments/75q0qi/im_shirley_wu_freelance_data_visualization/

# to-do

Read:  

https://github.com/d3/d3/blob/master/API.md#selections-d3-selection
https://github.com/d3/d3-selection
https://github.com/d3/d3-scale
https://github.com/d3/d3-axis
https://github.com/d3/d3-shape
https://github.com/d3/d3-transition
https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths
https://bost.ocks.org/mike/constancy/
http://github.com/d3/d3-force
https://medium.com/@sxywu/understanding-the-force-ef1237017d5

Watch:
Abusing The Force Talk
https://vallandingham.me/abusing_the_force.html
https://www.youtube.com/watch?v=Mucmb33711A
http://vallandingham.me/force_talk/#0

related (not exactly Shirley's recommendations, coisas que achei pesquisando):
http://learnjsdata.com/
https://gojs.net/latest/index.html
https://bl.ocks.org/maegul/7d8e7342c649fdc077a6984e52da4b62
https://bl.ocks.org/mbostock/6526445e2b44303eebf21da3b6627320
https://observablehq.com/@distantshape/charting-distribution-referral-changes-beeswarm-plot
https://observablehq.com/@mbostock/pachinko-simulator
https://hi.stamen.com/an-ode-to-d3-js-projections-9d6477d6da0b
https://medium.com/visualizing-the-field/there-be-dragons-dataviz-in-the-industry-652e712394a0
https://www.youtube.com/watch?v=CkFktv0p3pw (Composing D3.js Visuals with Vue.js Workshop)
https://medium.com/@zanarmstrong/why-choose-scrollytelling-steppers-155a59dd97fe
https://www.youtube.com/watch?v=W5AdUcJDHo0&list=PLCC436JpVnK3KpieWtxYN6aC2-exR_IxH&index=8 (Animating the Virtual DOM - Sarah Drasner aka @sarah_edo at @ReactEurope 2017)
https://vuejs.org/v2/guide/
https://levelup.gitconnected.com/d3-js-and-vue-js-7a6a721eb79f
https://valhead.com/2017/04/27/animation-in-dataviz-data-sketches/

Shirley's examples:
http://sxywu.com/obamas/
http://sxywu.com/80k/

Learn: https://bl.ocks.org/-/about
Use:   https://blockbuilder.org/
Use:   https://blockbuilder.org/search

http://sxywu.com/d3intro/


https://github.com/d3/d3/blob/master/API.md



# AGENDA

D3 Ecosystem

Selections
Data binding
Enter-append

Scales
Shapes

Update & Exit
Transitions

Forces

# D3 Ecosystem

API Reference:

Selections
Scales & Axes
Shapes
Forces

Bl.ocks & Blockbuilder (search)


Selections and Data
------------------------------------------------------

https://github.com/d3/d3-selection

```html
  <svg>
    <rect />
    <rect />
    <rect />
    <rect />
    <rect />
  </svg>
  <script>
    var data = [100, 250, 175, 200, 120];
    
    d3.selectAll('rect')
    	.data(data)
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', 'blue')
    	.attr('stroke', '#fff');

  </script>
```

Let's analyse this script:

`d3.select/selectAll('css_selector')`
this returns an array with the DOM elements that you've selected, with some functions wrapped around it.
and then all the functions are available to use on these elements.

`.data(data)`
"here's where I think a lot of the magic happens": with this function you pass in an array of data, and d3 will bind the data, one to one, to the elements in your selection. Apparently it creates a property/attribute `__data__` in the element, and its value is the respective value in the array of data that was passed in.

The core of D3 is this: "you take some data and then you apply/bind it to the DOM element and then you can access the data because it's literally been bound to the element in this way."

```javascript
   	.attr('x', (d, i) => i * rectWidth)
   	.attr('y', d => height - d)
   	.attr('width', rectWidth)
   	.attr('height', d => d)
   	.attr('fill', 'blue')
    .attr('stroke', '#fff');
```
"Then once you've bound that to each of the elements, you can use that data do specify what your element should do" (or look like, I guess).

So what d3 does is: loop through each rectangle in the selection, and passes in the data that's been bound to that specific element, as well as the index of that element in that selection array that was generated by d3.select/selectAll. And then you basically use a function to apply that value, that is, to specify what you want returned as the value of, in this case, an attribute.

For example, in `.attr('x', (d, i) => i * rectWidth)` you're saying, "hey, for each of these rectangle elements, this is what I want my x attribute to be.".

Notar que essa função que vai buscar / calcular o valor que se quer atribuir ao atributo em questão deve sempre ter um `return`, para o d3 conseguir identificar o valor que vai ser usado. No entanto, dentro da definição da função, é possível incluir, por exemplo, um `console.log`.

```js
    d3.selectAll('rect')
    	.data(data)
    	.attr('x', function(d, i) {
        console.log(i, d, i * rectWidth, height - d); // logging
        return i * rectWidth})
    	.attr('y', d => height - d)
```

**svg**

Coordinate system goes like
         x
  0 ---------------- >
  |
  |
y |
  |
  |
  v


Enter - Append
------------------------------------------------------

```html
  <svg></svg>
  <script>
    var rectWidth = 100;
    var height = 300;
    var data = [100, 250, 175, 200, 120];
    
    var svg = d3.select('svg');
    svg.selectAll('rect')
    	.data(data)
    	.enter().append('rect')
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', 'blue')
    	.attr('stroke', '#fff');

  </script>
```

This piece of code gives the same result. It did not explicitly declared the <rect> elements.

But: `svg.selectAll('rect')` --> what are we even selecting?!

It's an empty selection! But how are those bars appearing?

Here's the magic: `.data(data).enter().append('rect')`

> So when we do .data and we enter in the set of data, we pass in the set of data like we did before. This's what .data is calculating. It's saying, here is all my data that I had been posting and this all the rectangle elements that exist on the screen right now which just happens to be zero. Which means I need five rectangles, I need to create five rectangles to match that data. And that's all .data figures out. 

> And then what .enter comes and does is, it says, okay, I need to have five place holders for the right elements to make sure it matches the data. So, it just puts in these five place holders. 

> And then finally, when you .append, it takes those placeholders and actually creates rectangle and rect elements out of them, and also at the same time binds all of that data. Yeah, so that's essentially what's happening for data Enter-Append

Exemplo 2, comentando a sequência.

```js
		var rectWidth = 100;
    var height = 300;
    var data = [100, 250, 175, 200, 120];
    
    var svg = d3.select('svg');
    let enter = svg.selectAll('rect');
//    	.data(data)
//    	.enter().append('rect')
//    	.attr('x', (d, i) => i * rectWidth)
//    	.attr('y', d => height - d)
//    	.attr('width', rectWidth)
//    	.attr('height', d => d)
//    	.attr('fill', 'blue')
//    	.attr('stroke', '#fff');
    console.log(enter);
```
Esse objeto `enter` vai estar vazio.

i. Aí tira o comentário da linha `.data(data)`. O objeto agora vai ter length 5, vazia por dentro.

> So `_groups` is essentially what D3 knows is on the screen.

Em `_enter`, vemos os 5 placeholders, vazios, mas com os respectivos valores de `data` associados.

ii. quando tira o comentário de `.enter()`, vemos os placeholders dentro de `_groups`.

iii. quando finalmente tira o de `.append('rect')`, we get the rectangles elements, with the data bound.

À medida que acrescentamos valores à array de dados, novos elementos vão sendo criados! 

> This is why D3 stands for data driven documents, because the idea is the dom should reflect the data that you have.

Como os valores que estão sendo atribuídos aos atributos vêm de funções, dá para fazer muitas coisas. Tipo, colorir com outra cor as barras de valor superior a tanto. 

> And that's the beauty of D 3 that once you have the data bound, you can do absolutely anything with it. You can return for the functions. You can do anything you want as long as it returns a valid value for that specific attribute.

```js
		var rectWidth = 50;
    var height = 300;
    var data = [100, 250, 175, 200, 120, 230, 50];
    let threshold = 230;
    
    var svg = d3.select('svg');
    let enter = svg.selectAll('rect')
    	.data(data)
    	.enter()
      .append('rect')
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', function(d) {
        if (d > threshold) return 'firebrick'
        else return 'dodgerblue'})
    	.attr('stroke', '#fff');
    console.log(enter);
```
> How to check the state of the DOM elements on the screen and what data has been bound to them?

  <script>
		var rectWidth = 50;
    var height = 300;
    var data = [100, 250, 175, 200, 120, 230, 50];
    let threshold = 230;

    var svg = d3.select('svg');
    let selecao = svg.selectAll('rect')
    	.data(data)
    	.enter()
      .append('rect')
    	.attr('x', (d, i) => i * rectWidth)
    	.attr('y', d => height - d)
    	.attr('width', rectWidth)
    	.attr('height', d => d)
    	.attr('fill', function(d) {
        if (d>threshold) return 'firebrick'
        else return 'dodgerblue'})
    	.attr('stroke', '#fff');
    console.log(selecao);
    console.log(selecao.nodes());
    console.log(selecao._groups[0]);
  </script>

Esses dois últimos logs retornam essencialmente a mesma coisa.

(Mas `console.log(selecao.nodes() === selecao._groups[0])` retorna `false`.)

```js
  console.log(selecao);
  console.log(selecao.nodes());
  console.log(selecao._groups[0]);
  console.log(selecao.data());
```

Esse `selecao.data()`, com `data()` sem nenhum parâmetro, retorna uma array com os dados que foram amarrados.

> I think there's nothing really special about what D3 is doing So D3 is just supposed to be kind of this utility function, this tool to help you manipulate the DOM. So if you use SVG, if you use Canvas, if you use HTML, D3 is basically just a tool for you to manipulate that.

O exemplo de quando já existem dois <rect> hardcoded dentro de <svg>, e a matriz de dados tem 5 elementos. Com `.data()`, são criados placeholders para os rects que ainda não existem (3) e os dados (os três últimos elementos) são amarrados a esses três rects, e os dois <rect>s já existentes aparecem em `._groups`. Mas depois que é feito um `.append()`, só permanecem em `.groups` os três rects que foram criados por `.append()` (embora ele tenha um length de 5! Muito doido).


Scales and Axes
------------------------------------------------------

https://github.com/d3/d3-scale

> I like to think of it as like data binding is one of the core parts of D3 and then also enter-update-exit is one of the core parts of D3. And I personally maybe in a biased view think that if you just grasp those two the rest of the D3 library makes so much sense. Shirley Wu: Okay, so this is where we kinda go a little bit outside that core part and then just have a little bit of fun or what I think is fun.

Mike Bostock:
> If visualization is constructing “visual representations of abstract data to amplify cognition”, then perhaps the most important concept in D3 is the scale, which maps a dimension of abstract data to a visual variable.

> for my examples thus far we give really nice values, right? Between zero to 200 renders nicely on the screen. But what if you had data whose values were between zero and one. If you just rendered that as height, it won't really show up for you. Or will like, if your height was you know a thousand something. Like 2,000, or 10,000 or something like that.

Types os scale in D3:

* Continuous (Linear, Power, Log, Identity, Time)
* Sequential
* Diverging
* Quantize
* Quantile
* Threshold
* Ordinal (Band, Point)

SCALE: mapping from *data attributes, values (domain)* to *to display (range)*

date  -> x-value
value -> y-value
value -> opacity
etc.

To set the _domain_ and the _range_:

```js
  d3.scaleLinear()
    .domain([min, max]) // input
    .range([min, max]); // output
```

How would you get min and max?
```js
// get min/max
var min = d3.min(data, d => d[city]); // "city" would be the "accessor"
var max = d3.max(data, d => d[city]);

// or use extent, which gives back [min, max]
var extent = d3.extent(data, d => d[city]);

var yScale = d3.scaleLinear()
  .domain(extent)
  .range([height, 0]);
```

Scales I use often

// continuous
d3.scaleLinear()
d3.scaleLog()
d3.scaleTime()

// ordinal
d3.scaleBand()

Ver `d3.timeFormat()`, `d3.scaleQuantize()`, `d3.scaleTime()`

### Axis

https://github.com/d3/d3-axis

Scales are really the mapping, the translation.
To display de axis, there's d3.axis
Takes the scale and renders it, translates it to a set of axis. It renders your axis into the DOM.

```js
// get min/max
var min = d3.min(data, d => d[city]);
var max = d3.max(data, d => d[city]);

// or use extent, which gives back [min, max]
var extent = d3.extent(data, d => d[city]);

var yScale = d3.scaleLinear()
  .domain(extent)
  .range([height, 0]);

// display axis
var yAxis = d3.axisLeft()
  .scale(yScale); // pass in a scale

d3.select('svg')
  // create a group element (o container!) we can translate 
  // so that the axis will be visible in SVG
  .append('g')
  .attr('transform', 'translate(40, 20)')
  // selection.call(yAxis) is the same as yAxis(selection)
  // and an axis will be created within the selection
  .call(yAxis); // render the axis, returns the axis selection.
```

<g> is an svg element that is like a container that helps you have other svg elements inside it.

svg allows you to nest elements, so this <g> is a container where you can nest all the other elements into. an then you can apply transformations to the whole group element.

What d3 does under the hood is creating a bunch of <path> and <text> svg elements -- que serão criados dentro desse <g>.

O translate te permite posicionar os eixos em um local diferente de `0,0`..

Como se formata?

```js
     	var yAxis = d3.axisLeft()
        .ticks(20) // vai por 20 divisões
      	.scale(yScale);
```

`axis.tickFormat([format])`
`axis.tickFormat(d3.format(",.0f"));`

Dá para passar uma função, e aí formatar condicionalmente.

Para ver o objeto:

```js
      let eixo = d3.select('svg').append('g')
        .attr('transform', 'translate(40, 20)')
      	.call(yAxis);
      
      console.log(eixo);
```
Vai exibir isso no console:

```js
ut {_groups: Array(1), _parents: Array(1)}
_groups: Array(1)
0: Array(1)
0: g
childNodes: NodeList(13)
// a lista de elementos que formam o eixo aqui.
```

Se fizer `console.log(eixo.nodes());`, retorna isso aqui no console (a mesma estrutura anterior, mas a partir do nível 4 de profundidade):

[g]
0: g
childNodes: NodeList(13)

```js
      let texto = eixo.selectAll('text')
      console.log(texto);
      console.log(texto.nodes());
```
 Isso seleciona todos os elementos svgs que são "text", e os loga no console.

Mostra os dados que estão amarrados a esses elementos: `console.log(texto.data());`

Formata condicionalmente o texto dos labels:
```js
      let texto2 = eixo.selectAll('text')
        .attr('fill', function(d) {
          return d > 60 ? "red" :  "blue";})
```

Notar que podemos encadear seleções. Nesse exemplo, https://bl.ocks.org/tiagombp/9b899d65f0d2ac77d02a7ef7d7228f4a,
fizemos o seguinte:

```js
      let eixo = d3.select('svg').append('g')
        .attr('transform', 'translate(40, 20)')
      	.call(yAxis);

      let texto2 = eixo.selectAll('text')
        .attr('fill', function(d) {
          return d > 60 ? "red" :  "blue";})
```

```js
console.log(yScale(50)); // o yScale(), como definimos, nada mais é que uma função, para a qual podem ser passados valores. Ele vai retornar a altura em pixels que corresponde a 50 graus, conforme o domínio e o range que foi definido.
```

Notar que quando fizemos:

```js
  let eixo_x = d3.axisBottom()
      .scale(xScale);
```
Esse `eixo_x` é uma função. Para efetivamente criar o eixo no DOM, poderíamos fazer:

`eixo_x(svg.append('g'))`

Onde `svg` representa `d3.select('svg')`.

No exemplo, em vez de fazer assim, fizemos:

```js
  let EixoX = svg //d3.select('svg')
    .append('g')
    .call(eixo_x);
```

No `d3.axis` também podemos acrescentar `.ticks(qde_ticks)`, ou:
`.tickFormat(d => d.getMonth())`
ou
`.tickFormat(d => d3.timeFormat('%b %Y')(d));`
que dá no mesmo que:
`.tickFormat(d3.timeFormat('%b %Y'))`


### Exercício!
1. draw the bars using the right scales
2. get the axes


Shapes
------------------------------------------------------

SVG Elements: rect, circle, text, path etc.

For `<path>`: https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths

### d3.shapes

#### Line charts with `d3.line()`

d3-shape calculates the path attribute so we don't have to
https://github.com/d3/d3-shape

Curves: different functions for different types of curves.

d3.line() figures out the path attribute such that it just draws a line through all of these points.

Cria uma função que vai converter os dados passados a ela num <path> que conecte todos os pontos dos dados, por meio de linhas e curvas.

`d3.line()`:
Input: array of objects (the objects being the data points do be plotted).
Output: path that connects each point (object) with lines or curves. (`d3.curve*` oferece várias opções de suavização)

```js
var data = [
  {date: new Date(2007, 3, 24), value: 93.24},
  {date: new Date(2007, 3, 25), value: 95.35},
  {date: new Date(2007, 3, 26), value: 98.84},
  {date: new Date(2007, 3, 27), value: 99.92},
  {date: new Date(2007, 3, 30), value: 99.80},
  {date: new Date(2007, 4,  1), value: 99.47},
  …
];

var line = d3.line()
  .x(d => xScale(d.date))
  .y(d => yScale(d.value));

d3.select('svg')
  .append('path')
  .attr('d', line(data));
```
1. Criam-se funções de escala com `d3.scale` (parâmetros: as escalas)
2. Cria-se função de linha com `d3.line()`, a partir das funções de escala.
3. Faz-se um append de um <path> no svg, cujo atributo `d` vai ser determinado pelo resultado da chamada da função de linha sobre os dados.
Obs.: Não precisa de `enter()`, pq só precisamos de um único elemento path. Só se usa enter-append quando não se tem ao certo o número de elementos que serão necessários. E não precisa do `data()` porque os dados já estão sendo passados como argumento da função geradora da linha.
Obs.2: O path é fechado, e por padrão o fundo é preto. Por isso, usar um `.attr('fill', 'none');`. Às vezes o padrão é `stroke`: `none`.

Para fazer a curva ficar err... curva, é só usar um `d3.curve...` na corrente do `d3.line()` (https://github.com/d3/d3-shape). Por exemplo, `d3.curveCatmullRom`, `d3.curveStep`...
> "Just one extra line additional whereas if you look under the hood the path d attributes are vastly different to render the different curves."

Para fazer um corte nos dados, lá dentro de `d3.tsv`:
```js
// em vez de data.forEach(d => {...})
data = data.slice(0, 100); // para pegar só os primeiros 100 datapoints (101, na verdade)
data.forEach(d => {...})

```

**Resumo**
`dados` --> 
funções criadas com `d3.scale()` --> 
função criada com `d3.line()` --> 
`d3.select('svg').append('path').attr('d', (`função criada com `d3.line()` aplicada`) )`


#### Pie charts with `d3.pie()`

Duas partes: 

*primeira parte*, `d3.pie()`: que vai simplesmente pegar os dados e gerar um objeto com os ângulos iniciais e finais que correspondem aos valores dos dados que foram passados.

```js
var pie = d3.pie();

// input
var data = [1, 1, 2, 3, 5, 8, 13, 21];

pie(data);

// output
[
  {"data":  1, "value":  1, "startAngle": 6.050474740247008, "endAngle": 6.166830023713296, "padAngle": 0},
  {"data":  1, "value":  1, "startAngle": 6.166830023713296, "endAngle": 6.283185307179584, "padAngle": 0},
  {"data":  2, "value":  2, "startAngle": 5.817764173314431, "endAngle": 6.050474740247008, "padAngle": 0},
  {"data":  3, "value":  3, "startAngle": 5.468698322915565, "endAngle": 5.817764173314431, "padAngle": 0},
  {"data":  5, "value":  5, "startAngle": 4.886921905584122, "endAngle": 5.468698322915565, "padAngle": 0},
  {"data":  8, "value":  8, "startAngle": 3.956079637853813, "endAngle": 4.886921905584122, "padAngle": 0},
  {"data": 13, "value": 13, "startAngle": 2.443460952792061, "endAngle": 3.956079637853813, "padAngle": 0},
  {"data": 21, "value": 21, "startAngle": 0.000000000000000, "endAngle": 2.443460952792061, "padAngle": 0}
]
```

*segunda parte*, pega-se o resultado da função criada com `d3.pie()` e passa-se para uma função criada com `d3.arc()`, gerando-se o código correspondente ao atributo `d` do <path>.

```js
  var colors = d3.scaleOrdinal(d3.schemeCategory10);
  var data = [1, 1, 2, 3, 5, 8, 13, 21];
  var pies = d3.pie()(data);

  var arc = d3.arc()
    .innerRadius(0)
    .outerRadius(150)
    .startAngle(d => d.startAngle)
    .endAngle(d => d.endAngle);

  var svg = d3.select('svg')
  	.append('g')
  	.attr('transform', 'translate(200,200)');
  svg.selectAll('path')
  	.data(pies).enter().append('path')
  	.attr('d', function(d) {return arc(d)}) // legal colocar um console.log(d, arc(d)) aqui!
  	.attr('fill', (d, i) => colors(d.value))
  	.attr('stroke', '#fff');
```

(as cores estão dentro de `d3.scale`, já que cores são basicamente um tipo de escala de categoria).

```js
let colors = d3.scaleOrdinal()
  .range(d3.schemeCategory10); // defino as cores de saída e não precisa passar um domain!
```

Muito do que d3 faz é converter dados em algo que <svg> ou <canvas> possa entender.

dados --> <<d3 magic, por meio de uma série de funções>> --> atributos de elementos de <svg> 


## Enter-Update-Exit

https://bost.ocks.org/mike/constancy/

```js
  // bars includes update selection
  var bars = svg.selectAll('rect')
    .data(data, d => d);

  // exit
  bars.exit().remove();

  // enter
  var enter = bars.enter().append('rect')
    .attr('width', rectWidth)
    .attr('stroke', '#fff');

  // enter + update
  bars = enter.merge(bars)
    .attr('x', (d, i) => i * rectWidth)
    .attr('y', d => height - d)
    .attr('height', d => d)
    .attr('fill', d => colors(d));
```

`bars` is the selection. Then the `.data()` will evaluate three selections:
* _update selection_, with the bound-elements that match the new data: `bars` (that is, what `.data`gives back)
* _enter  selection_, with the data not currently bound to the current elements `bars.enter()`
* _exit   selection_, with the bound-elements that don't match the new data. `bars.exit()`

all this matching is done via the KEY FUNCTION, which establishes the unique identifiers for every data point accross the datasets of all states.

In this example, the **exit selection** is being simply removed from the screen, with `.remove()`.

For the **enter selection**, Shirley likes to chain the attributes that don't depend on the data.

Normalmente não trabalhamos com a "enter" selection e com a "update" selection de forma separada, mas juntas, usando o `merge`.

No código, `bars = enter.merge(bars)`

`enter` é a _enter selection_ : 
```js var enter = bars.enter().append('rect')
    .attr('width', rectWidth)
    .attr('stroke', '#fff');
```
e `bars` é a update selection, pois é o retorno de `.data()`:
```js
  var bars = svg.selectAll('rect')
    .data(data, d => d);
```
`bars = enter.merge(bars)` está juntando as duas seleções e amarrando essa nova seleção a `bars`.

Shirley:
> Usually I want to set the things that don't depend on data change, and then I want to take everything that's still on the screen, the added plus remaining, and set attributes on that -- attributes that DO depend on the data.


## Animating Transitions

d3.interpolation
GreenSock

```js
var t = d3.transition() // <- defines transition, syncs animation everywhere it's used
  .duration(1000);      //    TEM QUE FICAR DENTRO DA FUNÇÃO QUE É CHAMADA! Se não, reseta.
var svg = d3.select('svg');
   
var bars = svg.selectAll('rect')
  .data(data, d => d);

// exit
bars.exit().transition(t) // <- pass in the transition already defined ("t") anytime you call .transition
  .attr('y', height)      // <- attributes changed after .transition make the state B to where you
  .attr('height', 0)      //    are transitioning
  .remove();

// enter
var enter = bars.enter().append('rect')
  .attr('width', rectWidth)
  .attr('stroke', '#fff')
  .attr('y', height);  // <- attributes set before the .transition, that get changed after .transition:
// enter + update      //    that's the state A from where you are transitioning
bars = enter.merge(bars)
  .attr('x', (d, i) => i * rectWidth)
  .attr('fill', d => colors(d))
  .transition(t) // <- pass in the transition already defined ("t") anytime you call .transition
  .attr('y', d => height - d) // <- everything after .transition make the state B to where you
  .attr('height', d => d);    //    are transitioning
```

> Maybe the *exit* selection should come after the *enter* selection? Would people understand it more easily?

Na verdade, depende se na `enter+update` você redefiniu a variável que recebe o retorno de `.data` (aqui em cima, `bars`). Se sim, a `exit` tem que vir antes dessa redefinição! Caso só tenha usado um `enter.merge(bars)` na `enter+update`, aí `exit` pode vir depois. Mas em geral é melhor remover antes, pq vc pode precisar dessa redefinição.

!!! _you can't call `.enter()` on any selection, but only on what `.data()` returned!_

### Solução exercício

Atenção! No starter code dela, os atributos do css para `svg` estão sem os "px":

```css
  svg {
    width: 800px;
    height: 600px;
  };
```

0. Código inicial

```js
  // properties
  var radius = 10;
  var duration = 1500;
  var width = 800;
  var height = 600;
  var svg = d3.select('body').append('svg');
  // scales
  var xScale = d3.scaleBand()
    .rangeRound([0, width]);
  var yScale = d3.scaleLinear()
    .range([height, 0]);
  var colorScale = d3.scaleOrdinal(d3.schemeCategory10);
  
  function update(data, year) {
   
  }
  
  d3.csv('barleyfull.csv', function(err, response) {
    response.forEach(function(d) {
      // convert yield and year from string to int
      d.year = +d.year;
      d.yield = +d.yield;
      // use gen and site as the unique key for each datum
      d.key = d.site + ':' + d.gen;
    });
    
    console.log(response) // conseguimos ver response aqui. Pq?

    console.log(response.map(d => d.site));
    
    var startYear = 1927;
    var numYears = 9;
    var index = 0;
//     setInterval(() => {
//       update(response, startYear + (index % numYears));
//       index += 1;
//     }, 1000)
  });
```

Aparentemente, `response` vira uma variável / objeto que pode ser usado fora do bloco `d3.csv()`. 
__ENTENDER ISSO__

1. Determinar domínios

1.0 `x` -- Experimentos

A variável é categórica.

(código a ser inserido logo depois do bloco `d3.csv()`)

```js
// x
console.log(response.site); // gera undefined
console.log(response.map(d => d.site)); // gera um array com todos os sites
console.log(d3.map(response, d => d.site)); // gera algo q nem sei explicar o que é, mas
                                            // é um objeto que parece possuir elementos cujas
                                            // chaves são os valores únicos de "site"
console.log(d3.map(response, d => d.site).keys()); // retorna só as chaves desse objeto, que são os
                                                   // valores únicos de "site"
```

1.1 `x` -- de verdade

Aparentemente, se você passar a array completa de `site` como domínio, `d3` vai usar (corretamente) apenas os valores únicos, então em tese não seria necessário se preocupar em obter a lista de valores únicos.

```js
let xDomain = response.map(d => d.site); // gera a array e atribui a xDomain

xScale.domain(xDomain); // atualiza a função xScale com o domínio.
                        // dúvida! por que não precisa fazer algo como:
                        // xScale = xScale.domain(xDomain);

console.log("Domínio de x", xScale.domain(), xScale.range()) // chamar .domain() e .range() 
                                                             // retornam as arrays de dominio
                                                             // e range
```

1.2 `y` é numérico, então basta passar o extent.

```js
let yDomain = d3.extent(response, d => d.yield);

yScale.domain(yDomain);
```

2. Desenhando os círculos

(código na sequência do bloco `var startYear = 1927;`)

```js
update(response, startYear);
```

Editando a função `update`

```js
  function update(data, year) {

    // 1. Filtrar os dados para o ano da vez
    data = data.filter(d => d.year === year);

    console.log(data);

    // 2. Get all the circles (that doesn't yet exist) and bind data to it
    let circles = svg.selectAll('circle')
      .data(data, d => d.key) // aqui definimos a key function, usando a key que já tinha
                              // sido criada no processamento do CSV.

    // 5. The exit selection
    circles.exit().remove();

    // 3. The enter selection - here we create de circles, and set any attribute that does not
    //                          "depend" on the data
    enter = circles.enter().append('circle')
      .attr('r', radius); // é o único atributo que não depende dos dados, 
                          // é uma constante.  

                          // Note que, depois de essa linha ser executada,
                          // já devo enxergar os <circle> no DOM.
                          // IMPORTANTE
                          // .enter() é chamada em cima de `circles`, pq
                          // essa é a variável que está amarrada ao
                          // que a chamada a .data() retornou.

    // 4. The enter + update selection
    circles = enter.merge(circles) // aqui se está sobreescrevendo o que .data() havia retornado, lá
                                   // no item 2, com a enter+update selection.
                                   // nesse caso, a exit selection tem que vir antes dessa
                                   // redefinição / overriding, caso contrário a .exit() function
                                   // não vai funcionar sobre a seleção correta

      .attr('cx', d => xScale(d.site))   // se olharmos no html, já veremos os circles 
                                         // com esse atributo definido!
      .attr('cy', d => yScale(d.yield))  // depois de definirmos o cy, como já temos cx e r,
                                         // a chamada à função já deve fazer aparecer 
                                         // os círculos na tela!
      .attr('fill', d => colorScale(d.gen)); // aqui define o preenchimento a partir da
                                             // escala de cor que ela criou (que só tem 10
                                             // valores, mas tudo bem)   
  }
```

A parte da `enter` e `enter+update` podem ficar juntas (shirley diz que só vale a pena separar quando vc estiver usando elementos encadeados (nested):

```js
    circles.enter().append('circle')    // enter
      .attr('r', radius)
      .merge(circles)                   // enter+update
      .attr('cx', d => xScale(d.site))   
      .attr('cy', d => yScale(d.yield))
      .attr('fill', d => colorScale(d.gen));  
```

3. Transitions

```js
  function update(data, year) {

    // 1. Filtrar os dados para o ano da vez
    data = data.filter(d => d.year === year);

    // 6. define a transição
    let t = d3.transition().duration(1000);

    console.log(data);

    // 2. Get all the circles (that doesn't yet exist) and bind data to it
    let circles = svg.selectAll('circle')
      .data(data, d => d.key) // aqui definimos a key function, usando a key que já tinha
                              // sido criada no processamento do CSV.

    // 5. exit selection
    circles.exit()
      .transition(t) // 7. acrescenta a transição
      .attr('r', 0)  //    com uma frescurinha de animar uma redução do raio até 0
      .remove();

    // 3. enter e 4. enter + update
    circles.enter().append('circle')    // enter
      .attr('r', radius)
      .attr('cy', d => yScale(d.yield))     // 8. acrescenta esse valor inicial, caso contrário
                                            //    o y, que está sendo animado entre uma chamada e
                                            //    outra, começaria do zero (que é o default), 
                                            //    o que daria um efeito
                                            //    de os círculos caírem do alto da tela.
      .merge(circles)                   // enter+update
      .attr('cx', d => xScale(d.site))   
      .attr('fill', d => colorScale(d.gen))
      .transition(t)                         // 7. acrescenta a transição
      .attr('cy', d => yScale(d.yield))      //    animando apenas posição y
```

O que vem depois de `.transition()` é o que vai ser ANIMADO!

## Force Layout

https://medium.com/@sxywu/understanding-the-force-ef1237017d5 (v3)
http://github.com/d3/d3-force

Calculates X and Y positions of each of the nodes, with the optimal layout: as little overlap of links as possible.

Attractive forces: pull nodes together (conserves space) (the hearts diagram)
Repulsive forces:  push nodes apart (makes sure they don't overlap) (the broken hears diagram)

Force layout repeats these calculations, figuring out x and y positions of the red node, given all the forces, attractive and repulsive, that the other nodes are applying on it, and then figures this out for every single node, getting all the x and y positions --> one tick. And then it runs thousands of iterations of "ticks" to converge to an optimal layout.

In v4 you can provide sort of focal points. 

Position (forceX, forceY). Collision (forceCollide).

Performance issues. Alpha-min.

## D3 + React

http://slides.com/shirleywu/deck#/
https://medium.com/@sxywu/on-d3-react-and-a-little-bit-of-flux-88a226f328f3

D3
interactive dataviz
enter-update-exit pattern

REACT
single-page apps whose data change over time
virtual DOM diffing

THEY BOTH SOLVE THE SAME PROBLEM & WANT CONTROL OF THE DOM

D3 VS. REACT
component structure

data calculation

rendering

### APPROACH #1 - USE CASE: APP WITH A SMALL DATASET AND SIMPLE VISUALIZATION

React for structure
D3 for data calculation
React for rendering

Pro: 
* Clean, easy to reason about

Con: 
* lifecycle for every tick -> unperformant
* Cannot use D3 functions that need access to DOM

### APPROACH #2 - USE CASE: APP WITH A SMALL DATASET BUT HIGHLY INTERACTIVE VISUALIZATION

* React for structure
* D3 for data calculation
* D3 AND React for rendering:
​  - React for elements
  - D3 for attributes
https://medium.com/@sxywu/on-d3-react-and-a-little-bit-of-flux-88a226f328f3

Pro: 
Takes advantage of respective strengths

Con: 
React component around all the nodes ->  unperformant
Makes people uncomfortable

### APPROACH #3 - USE CASE: APP WITH A LARGE DATASET AND FREQUENTLY UPDATING VISUALIZATION

* React for structure
* D3 for data calculation
* D3 for rendering

Pro: 
The viz scales!
Use all the d3 functions!

Con: 
Why you even React, bro?      
>Shirley: There's something that is amazingly beautiful about how react forces me to think about "componentizing" my visualizations, and so I love that and I also love using react for communication between each of the different components. So like if I have multiple visualizations that are linked together, so if this visualization affects what is displayed in this other visualization, react makes this communication super easy for me, whereas if I just used d3 I would have to use a bunch of dispatches to like do the communication. React makes that thought process super easy. And I also appreciate the fact that, like, my application isn't going to just have visualizations, right? I use react normally for all of those non-data viz parts of my app and use this approach for the visualization part.

### LESSONS LEARNED
* Never ever have React and D3 controlling same parts of the DOM (or else nasty bugs)
* Know the rules to break them
* Assess the needs of the project, then figure out the combination of D3 + React that makes sense



LESSONS LEARNED
Never ever have React and D3 controlling same parts of the DOM (or else nasty bugs)
  

Dúvidas
======================================================

Entender direito o que cada função retorna. Pq às vezes não preciso refazer os bindings? Tipo, no exemplo 3, dos circles, posso só usar um `enter.merge(circles)` sem reatribuir isso a `circles`. Ou na parte em que posso simplesmente chamar `xScale.domain(...)` e redefinir o `xScale` sem fazer um `xScale = xSclae.domain(...)`.

Aparentemente, `response` vira uma variável / objeto que pode ser usado fora do bloco `d3.csv()`. 

d3.scaleBand.rangeRound() ?

como os dados chegam... a partir dessas funções de leitura de csv, tsv, json.

o que o `.data()` retorna? Ela faz o bind, mas retorna algo. É um array de elementos com os respectivos dados amarrados?

Acho confuso isso:

```js
let line = d3.line() // uma função?
  .x(d => xScale(d.date)) // outra função dentro daquela função? se .x fosse um método do objeto d3.line, 
                          // seria mais fácil de entender. mas esses parênteses junto de "line"?
  .y()
```

Um problema que vejo no entendimento inicial: muitas coisas são criadas como funções, mas os nomes das variáveis usadas são nomes de coisas, não de ações. Tipo "line", "xScale" etc. Nos meus códigos, acho que vou usar nomes de verbos.

o `.data()` parece ser uma forma simples de fazer um `.attr('data', valores)` em lote, iterado para cada elemento do dataset, e mesmo que não existam ainda os elementos que receberão esse atributo (criados com `.enter()` e `.append()`)

`.call`? (d3.selection) ( aparentemente, `svg.append('g').call(eixo_y)` equivale a `eixo_y(svg.append('g'))` )

como manipular um dataset no JS / D3?

tb ainda não está claro quando o uso de uma função de algum módulo do d3 retorna um valor ou uma outra função.

o que é um pouco confuso é pq, enquanto vc está aparentemente só definindo uma variável, ele já está aplicando as funções e produzindo um efeito no gráfico.

diferença de fazer um d3.select e um document.querySelector / .getElementsByTagName?

(como eram as seleções no JS mesmo?)

como selecionar parent, sibling etc., sem jquery?

`<rect>` properties?

como faz console log numa chamada do d3?

o que é o "0" em `_groups`?

no exercício 1, no código que processa o arquivo .tsv, o que é esse `++d[city]`? Ela usa isso para converter para um tipo numérico, mas como funciona exatamente?

```js
      let EixoY = svg //d3.select('svg')
        .append('g')
        .attr('transform', 'translate(' + [margin.left, 0] + ')') // como o eixo foi construído com o yScale, que por sua vez já fora construíndo levando-se em consideração as margins top e bottom, só precisamos posicioná-lo horizontalmente.
        .call(eixo_y);
      
      // na verdade nem precisaria nomear as variáveis, EixoX e EixoY. só fazer o svg.append('g')...
```
qual a melhor prática? só chamo a função, sem nomear a variável?



Feedback
======================================================
Os exemplos ficariam mais claros com uma tabelinha mostrando os dados, ou parte deles, apenas para lembrar que variáveis estão presentes etc.
